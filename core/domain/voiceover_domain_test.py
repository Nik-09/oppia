# coding: utf-8
#
# Copyright 2024 The Oppia Authors. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS-IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for domain objects related to voiceovers."""

from __future__ import annotations

from core import feconf
from core import utils
from core.domain import state_domain
from core.domain import voiceover_domain
from core.tests import test_utils


class EntityVoiceoversUnitTests(test_utils.GenericTestBase):
    """Test for EntityVoiceover."""

    def setUp(self) -> None:
        super().setUp()

        dummy_manual_voiceover_dict = {
            'filename': 'filename1.mp3',
            'file_size_bytes': 3000,
            'needs_update': False,
            'duration_secs': 6.1
        }
        dummy_autogenerated_voiceover_dict = {
            'filename': 'filename2.mp3',
            'file_size_bytes': 3500,
            'needs_update': False,
            'duration_secs': 5.9
        }

        self.entity_voiceover = voiceover_domain.EntityVoiceover(
            entity_id='exp_id',
            entity_type=feconf.ENTITY_TYPE_EXPLORATION,
            entity_version=1,
            language_accent_code='en-US',
            voiceovers={
                'content_id_0': {
                    'manual': state_domain.Voiceover.from_dict(
                        dummy_manual_voiceover_dict),
                    'auto': state_domain.Voiceover.from_dict(
                        dummy_autogenerated_voiceover_dict)
                }
            }
        )
        self.entity_voiceover_dict = {
            'entity_id': 'exp_id',
            'entity_type': 'exploration',
            'entity_version': 1,
            'language_accent_code': 'en-US',
            'voiceovers': {
                'content_id_0': {
                    'manual': dummy_manual_voiceover_dict,
                    'auto': dummy_autogenerated_voiceover_dict
                }
            }
        }

    def test_to_dict_method_entity_voiceover_class(self) -> None:
        self.assertDictEqual(
            self.entity_voiceover.to_dict(), self.entity_voiceover_dict)

    def test_validate_entity_id(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'entity_id must be a string'
        ):
            self.entity_voiceover.entity_id = 123  # type: ignore[assignment]
            self.entity_voiceover.validate()

    def test_validate_entity_version(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'entity_version must be an int'
        ):
            self.entity_voiceover.entity_version = (
                'version')  # type: ignore[assignment]
            self.entity_voiceover.validate()

    def test_validate_entity_type(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'entity_type must be a string'
        ):
            self.entity_voiceover.entity_type = 1  # type: ignore[assignment]
            self.entity_voiceover.validate()

    def test_validate_datatype_of_voiceover_type(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'voiceover type must be string'
        ):
            self.entity_voiceover.voiceovers['content_id_0'][1] = None  # type: ignore[assignment]
            self.entity_voiceover.validate()

    def test_validate_choices_of_voiceover_type(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'The voiceover type must be either manual or auto'
        ):
            self.entity_voiceover.voiceovers['content_id_0']['random'] = None  # type: ignore[assignment]
            self.entity_voiceover.validate()

    def test_validate_language_accent_code(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'language_accent_code must be a string'
        ):
            self.entity_voiceover.language_accent_code = 1  # type: ignore[assignment]
            self.entity_voiceover.validate()

    def test_validate_content_id(self) -> None:
        # TODO(#13059): Here we use MyPy ignore because after we fully type
        # the codebase we plan to get rid of the tests that intentionally test
        # wrong inputs that we can normally catch by typing.
        with self.assertRaisesRegex(
            utils.ValidationError,
            'content_id must be a string'
        ):
            self.entity_voiceover.voiceovers[1] = {}  # type: ignore[assignment]
            self.entity_voiceover.validate()

    def test_add_voiceovers_correctly(self) -> None:
        dummy_new_voiceover_dict = {
            'filename': 'filename2.mp3',
            'file_size_bytes': 4000,
            'needs_update': False,
            'duration_secs': 6.0
        }
        new_voiceover_object = state_domain.Voiceover.from_dict(
            dummy_new_voiceover_dict)

        self.entity_voiceover.add_voiceover(
            content_id='content_id_0',
            voiceover_type='manual',
            voiceover=new_voiceover_object)

        self.assertDictEqual(
            self.entity_voiceover.voiceovers['content_id_0'][
                'manual'].to_dict(),
            dummy_new_voiceover_dict
        )

    def test_raise_exception_for_invalid_content_id_while_adding_voiceovers(
        self
    ) -> None:
        dummy_new_voiceover_dict = {
            'filename': 'filename2.mp3',
            'file_size_bytes': 4000,
            'needs_update': False,
            'duration_secs': 6.0
        }
        new_voiceover_object = state_domain.Voiceover.from_dict(
            dummy_new_voiceover_dict)

        with self.assertRaisesRegex(
            utils.ValidationError,
            'content_id must be a string'
        ):
            self.entity_voiceover.add_voiceover(
            content_id=1,
            voiceover_type='manual',
            voiceover=new_voiceover_object)

    def test_raise_exception_for_invalid_voiceover_type_while_adding_voiceovers(
        self
    ) -> None:
        dummy_new_voiceover_dict = {
            'filename': 'filename2.mp3',
            'file_size_bytes': 4000,
            'needs_update': False,
            'duration_secs': 6.0
        }
        new_voiceover_object = state_domain.Voiceover.from_dict(
            dummy_new_voiceover_dict)

        with self.assertRaisesRegex(
            utils.ValidationError,
            'The voiceover type must be either manual or auto'
        ):
            self.entity_voiceover.add_voiceover(
            content_id='content_id_0',
            voiceover_type='random',
            voiceover=new_voiceover_object)

    def test_raise_exception_for_invalid_content_id_while_removing_voiceovers(
        self
    ) -> None:
        with self.assertRaisesRegex(
            utils.ValidationError,
            'content_id must be a string'
        ):
            self.entity_voiceover.remove_voiceover(
            content_id=1,
            voiceover_type='manual')

    def test_raise_error_for_invalid_voiceover_type_while_removing_voiceovers(
        self
    ) -> None:
        with self.assertRaisesRegex(
            utils.ValidationError,
            'The voiceover type must be either manual or auto'
        ):
            self.entity_voiceover.remove_voiceover(
            content_id='content_id_0',
            voiceover_type='random')

    def test_removes_voiceover_correctly(self) -> None:
        self.entity_voiceover.remove_voiceover(
            content_id='content_id_0',
            voiceover_type='manual'
        )

        self.assertNotIn(
            'manual', self.entity_voiceover.voiceovers['content_id_0'].keys())

    def test_create_empty_entity_voiceover_object(self) -> None:
        empty_entity_voiceover_object = (
            voiceover_domain.EntityVoiceover.create_empty(
                'exp_id', 'exploration', 1, 'en-US'))

        self.assertEqual(empty_entity_voiceover_object.entity_id, 'exp_id')
        self.assertEqual(empty_entity_voiceover_object.entity_version, 1)
        self.assertEqual(
            empty_entity_voiceover_object.entity_type, 'exploration')
        self.assertEqual(
            empty_entity_voiceover_object.language_accent_code, 'en-US')
        self.assertEqual(empty_entity_voiceover_object.voiceovers, {})
